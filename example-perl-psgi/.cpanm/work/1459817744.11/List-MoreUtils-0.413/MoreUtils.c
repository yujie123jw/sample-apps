/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of MoreUtils.xs. Do not edit this file, edit MoreUtils.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "MoreUtils.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "multicall.h"
#include "ppport.h"

#ifndef aTHX
#  define aTHX
#  define pTHX
#endif

#ifdef SVf_IVisUV
#  define slu_sv_value(sv) (SvIOK(sv)) ? (SvIOK_UV(sv)) ? (NV)(SvUVX(sv)) : (NV)(SvIVX(sv)) : (SvNV(sv))
#else
#  define slu_sv_value(sv) (SvIOK(sv)) ? (NV)(SvIVX(sv)) : (SvNV(sv))
#endif

/*
 * Perl < 5.18 had some kind of different SvIV_please_nomg
 */
#if PERL_VERSION < 18
#undef SvIV_please_nomg
#  define SvIV_please_nomg(sv) \
	(!SvIOKp(sv) && (SvNOK(sv) || SvPOK(sv)) \
	    ? (SvIV_nomg(sv), SvIOK(sv))	  \
	    : SvIOK(sv))
#endif

/* compare left and right SVs. Returns:
 * -1: <
 *  0: ==
 *  1: >
 *  2: left or right was a NaN
 */
static I32
ncmp(SV* left, SV * right)
{
    /* Fortunately it seems NaN isn't IOK */
    if(SvAMAGIC(left) || SvAMAGIC(right))
	return SvIVX(amagic_call(left, right, ncmp_amg, 0));

    if (SvIV_please_nomg(right) && SvIV_please_nomg(left)) {
	if (!SvUOK(left)) {
	    const IV leftiv = SvIVX(left);
	    if (!SvUOK(right)) {
		/* ## IV <=> IV ## */
		const IV rightiv = SvIVX(right);
		return (leftiv > rightiv) - (leftiv < rightiv);
	    }
	    /* ## IV <=> UV ## */
	    if (leftiv < 0)
		/* As (b) is a UV, it's >=0, so it must be < */
		return -1;
	    {
		const UV rightuv = SvUVX(right);
		return ((UV)leftiv > rightuv) - ((UV)leftiv < rightuv);
	    }
	}

	if (SvUOK(right)) {
	    /* ## UV <=> UV ## */
	    const UV leftuv = SvUVX(left);
	    const UV rightuv = SvUVX(right);
	    return (leftuv > rightuv) - (leftuv < rightuv);
	}
	/* ## UV <=> IV ## */
	{
	    const IV rightiv = SvIVX(right);
	    if (rightiv < 0)
		/* As (a) is a UV, it's >=0, so it cannot be < */
		return 1;
	    {
		const UV leftuv = SvUVX(left);
		return (leftuv > (UV)rightiv) - (leftuv < (UV)rightiv);
	    }
	}
	assert(0); /* NOTREACHED */
    }
    else
    {
#ifdef SvNV_nomg
        NV const rnv = SvNV_nomg(right);
        NV const lnv = SvNV_nomg(left);
#else
        NV const rnv = slu_sv_value(right);
        NV const lnv = slu_sv_value(left);
#endif

#if defined(NAN_COMPARE_BROKEN) && defined(Perl_isnan)
        if (Perl_isnan(lnv) || Perl_isnan(rnv)) {
	    return 2;
        }
        return (lnv > rnv) - (lnv < rnv);
#else
        if (lnv < rnv)
	    return -1;
        if (lnv > rnv)
	    return 1;
        if (lnv == rnv)
            return 0;
        return 2;
#endif
    }
}

#define FUNC_NAME GvNAME(GvEGV(ST(items)))

/* shameless stolen from PadWalker */
#ifndef PadARRAY
typedef AV PADNAMELIST;
typedef SV PADNAME;
# if PERL_VERSION < 8 || (PERL_VERSION == 8 && !PERL_SUBVERSION)
typedef AV PADLIST;
typedef AV PAD;
# endif
# define PadlistARRAY(pl)       ((PAD **)AvARRAY(pl))
# define PadlistMAX(pl)         AvFILLp(pl)
# define PadlistNAMES(pl)       (*PadlistARRAY(pl))
# define PadnamelistARRAY(pnl)  ((PADNAME **)AvARRAY(pnl))
# define PadnamelistMAX(pnl)    AvFILLp(pnl)
# define PadARRAY               AvARRAY
# define PadnameIsOUR(pn)       !!(SvFLAGS(pn) & SVpad_OUR)
# define PadnameOURSTASH(pn)    SvOURSTASH(pn)
# define PadnameOUTER(pn)       !!SvFAKE(pn)
# define PadnamePV(pn)          (SvPOKp(pn) ? SvPVX(pn) : NULL)
#endif
#ifndef PadnameSV
# define PadnameSV(pn)          pn
#endif
#ifndef PadnameFLAGS
# define PadnameFLAGS(pn)       (SvFLAGS(PadnameSV(pn)))
#endif

static int 
in_pad (SV *code)
{
    GV *gv;
    HV *stash;
    CV *cv = sv_2cv(code, &stash, &gv, 0);
    PADLIST *pad_list = (CvPADLIST(cv));
    PADNAMELIST *pad_namelist = PadlistNAMES(pad_list);
    PADNAME **pad_names = PadnamelistARRAY(pad_namelist);
    int i;

    for (i=PadnamelistMAX(pad_namelist); i>=0; --i) {
	PADNAME* name_sv = PadnamelistARRAY(pad_namelist)[i];
	if (name_sv) {
	    char *name_str = PadnamePV(name_sv);
	    if (name_str) {

		/* perl < 5.6.0 does not yet have our */
#               ifdef SVpad_OUR
		if(PadnameIsOUR(name_sv))
		    continue;
#               endif

		if (!(PadnameFLAGS(name_sv)) & SVf_OK)
		    continue;

		if (strEQ(name_str, "$a") || strEQ(name_str, "$b"))
		    return 1;
	    }
	}
    }
    return 0;
}

#define WARN_OFF \
    SV *oldwarn = PL_curcop->cop_warnings; \
    PL_curcop->cop_warnings = pWARN_NONE;

#define WARN_ON \
    PL_curcop->cop_warnings = oldwarn;

#define EACH_ARRAY_BODY \
	int i;										\
	arrayeach_args * args;								\
	HV *stash = gv_stashpv("List::MoreUtils_ea", TRUE);				\
	CV *closure = newXS(NULL, XS_List__MoreUtils__array_iterator, __FILE__);	\
											\
	/* prototype */									\
	sv_setpv((SV*)closure, ";$");							\
											\
	New(0, args, 1, arrayeach_args);						\
	New(0, args->avs, items, AV*);							\
	args->navs = items;								\
	args->curidx = 0;								\
											\
	for (i = 0; i < items; i++) {							\
	    if(!arraylike(ST(i)))							\
	       croak_xs_usage(cv,  "\\@;\\@\\@...");					\
	    args->avs[i] = (AV*)SvRV(ST(i));						\
	    SvREFCNT_inc(args->avs[i]);							\
	}										\
											\
	CvXSUBANY(closure).any_ptr = args;						\
	RETVAL = newRV_noinc((SV*)closure);						\
											\
	/* in order to allow proper cleanup in DESTROY-handler */			\
	sv_bless(RETVAL, stash)


#define FOR_EACH(on_item)			\
    if(!codelike(code))				\
       croak_xs_usage(cv,  "code, ...");	\
						\
    if (items > 1) {				\
        dMULTICALL;				\
        int i;					\
        HV *stash;				\
        GV *gv;					\
        CV *_cv;				\
        SV **args = &PL_stack_base[ax];		\
        I32 gimme = G_SCALAR;			\
        _cv = sv_2cv(code, &stash, &gv, 0);	\
        PUSH_MULTICALL(_cv);			\
        SAVESPTR(GvSV(PL_defgv));		\
						\
        for(i = 1 ; i < items ; ++i) {		\
            GvSV(PL_defgv) = args[i];		\
            MULTICALL;				\
	    on_item;				\
        }					\
        POP_MULTICALL;				\
    }

#define TRUE_JUNCTION	\
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) ON_TRUE) \
    else ON_EMPTY;

#define FALSE_JUNCTION	\
    FOR_EACH(if (!SvTRUE(*PL_stack_sp)) ON_FALSE) \
    else ON_EMPTY;

/* #include "dhash.h" */

/* need this one for array_each() */
typedef struct {
    AV **avs;	    /* arrays over which to iterate in parallel */
    int navs;	    /* number of arrays */
    int curidx;	    /* the current index of the iterator */
} arrayeach_args;

/* used for natatime */
typedef struct {
    SV **svs;
    int nsvs;
    int curidx;
    int natatime;
} natatime_args;

void
insert_after (int idx, SV *what, AV *av) {
    int i, len;
    av_extend(av, (len = av_len(av) + 1));

    for (i = len; i > idx+1; i--) {
	SV **sv = av_fetch(av, i-1, FALSE);
	SvREFCNT_inc(*sv);
	av_store(av, i, *sv);
    }
    if (!av_store(av, idx+1, what))
	SvREFCNT_dec(what);
}

static int
is_like(SV *sv, const char *like)
{
    int likely = 0;
    if( sv_isobject( sv ) )
    {
        dSP;
        int count;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs( sv_2mortal( newSVsv( sv ) ) );
        XPUSHs( sv_2mortal( newSVpv( like, strlen(like) ) ) );
        PUTBACK;

        if( ( count = call_pv("overload::Method", G_SCALAR) ) )
        {
            I32 ax;
            SPAGAIN;

            SP -= count;
            ax = (SP - PL_stack_base) + 1;
            if( SvTRUE(ST(0)) )
                ++likely;
        }

        PUTBACK;
        FREETMPS;
        LEAVE;
    }

    return likely;
}

static int
is_array(SV *sv)
{
    return SvROK(sv) && ( SVt_PVAV == SvTYPE(SvRV(sv) ) );
}

static int
codelike(SV *code)
{
    SvGETMAGIC(code);
    return SvROK(code) && ( ( SVt_PVCV == SvTYPE(SvRV(code)) ) || ( is_like(code, "&{}" ) ) );
}

static int
arraylike(SV *array)
{
    SvGETMAGIC(array);
    return is_array(array) || is_like( array, "@{}" );
}

#line 331 "MoreUtils.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 475 "MoreUtils.c"

XS_EUPXS(XS_List__MoreUtils_ea_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_ea_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 327 "MoreUtils.xs"
    {
	int i;
	CV *code = (CV*)SvRV(sv);
	arrayeach_args *args = (arrayeach_args *)(CvXSUBANY(code).any_ptr);
	if (args) {
	    for (i = 0; i < args->navs; ++i)
		SvREFCNT_dec(args->avs[i]);
	    Safefree(args->avs);
	    Safefree(args);
	    CvXSUBANY(code).any_ptr = NULL;
	}
    }
#line 499 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_na_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_na_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 347 "MoreUtils.xs"
    {
	int i;
	CV *code = (CV*)SvRV(sv);
	natatime_args *args = (natatime_args *)(CvXSUBANY(code).any_ptr);
	if (args) {
	    for (i = 0; i < args->nsvs; ++i)
		SvREFCNT_dec(args->svs[i]);
	    Safefree(args->svs);
	    Safefree(args);
	    CvXSUBANY(code).any_ptr = NULL;
	}
    }
#line 527 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_any); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_any)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 367 "MoreUtils.xs"
{
#define ON_TRUE { POP_MULTICALL; XSRETURN_YES; }
#define ON_EMPTY XSRETURN_NO
    TRUE_JUNCTION;
    XSRETURN_NO;
#undef ON_EMPTY
#undef ON_TRUE
}
#line 551 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_all); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_all)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 381 "MoreUtils.xs"
{
#define ON_FALSE { POP_MULTICALL; XSRETURN_NO; }
#define ON_EMPTY XSRETURN_YES
    FALSE_JUNCTION;
    XSRETURN_YES;
#undef ON_EMPTY
#undef ON_FALSE
}
#line 575 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_none); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_none)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 396 "MoreUtils.xs"
{
#define ON_TRUE { POP_MULTICALL; XSRETURN_NO; }
#define ON_EMPTY XSRETURN_YES
    TRUE_JUNCTION;
    XSRETURN_YES;
#undef ON_EMPTY
#undef ON_TRUE
}
#line 599 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_notall); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_notall)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 410 "MoreUtils.xs"
{
#define ON_FALSE { POP_MULTICALL; XSRETURN_YES; }
#define ON_EMPTY XSRETURN_NO
    FALSE_JUNCTION;
    XSRETURN_NO;
#undef ON_EMPTY
#undef ON_FALSE
}
#line 623 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_one); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_one)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 424 "MoreUtils.xs"
{
    int found = 0;
#define ON_TRUE { if (found++) { POP_MULTICALL; XSRETURN_NO; }; }
#define ON_EMPTY XSRETURN_YES
    TRUE_JUNCTION;
    if (found)
        XSRETURN_YES;
    XSRETURN_NO;
#undef ON_EMPTY
#undef ON_TRUE
}
#line 650 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_any_u); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_any_u)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 441 "MoreUtils.xs"
{
#define ON_TRUE { POP_MULTICALL; XSRETURN_YES; }
#define ON_EMPTY XSRETURN_UNDEF
    TRUE_JUNCTION;
    XSRETURN_NO;
#undef ON_EMPTY
#undef ON_TRUE
}
#line 674 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_all_u); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_all_u)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 455 "MoreUtils.xs"
{
#define ON_FALSE { POP_MULTICALL; XSRETURN_NO; }
#define ON_EMPTY XSRETURN_UNDEF
    FALSE_JUNCTION;
    XSRETURN_YES;
#undef ON_EMPTY
#undef ON_FALSE
}
#line 698 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_none_u); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_none_u)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 470 "MoreUtils.xs"
{
#define ON_TRUE { POP_MULTICALL; XSRETURN_NO; }
#define ON_EMPTY XSRETURN_UNDEF
    TRUE_JUNCTION;
    XSRETURN_YES;
#undef ON_EMPTY
#undef ON_TRUE
}
#line 722 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_notall_u); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_notall_u)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 484 "MoreUtils.xs"
{
#define ON_FALSE { POP_MULTICALL; XSRETURN_YES; }
#define ON_EMPTY XSRETURN_UNDEF
    FALSE_JUNCTION;
    XSRETURN_NO;
#undef ON_EMPTY
#undef ON_FALSE
}
#line 746 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_one_u); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_one_u)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 498 "MoreUtils.xs"
{
    int found = 0;
#define ON_TRUE { if (found++) { POP_MULTICALL; XSRETURN_NO; }; }
#define ON_EMPTY XSRETURN_UNDEF
    TRUE_JUNCTION;
    if (found)
        XSRETURN_YES;
    XSRETURN_NO;
#undef ON_EMPTY
#undef ON_TRUE
}
#line 773 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_true); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_true)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 515 "MoreUtils.xs"
{
    I32 count = 0;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) count++);
    RETVAL = count;
}
#line 796 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_false); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_false)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 528 "MoreUtils.xs"
{
    I32 count = 0;
    FOR_EACH(if (!SvTRUE(*PL_stack_sp)) count++);
    RETVAL = count;
}
#line 820 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_firstidx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_firstidx)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 541 "MoreUtils.xs"
{
    RETVAL = -1;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) { RETVAL = i-1; break; });
}
#line 843 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_firstval); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_firstval)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 553 "MoreUtils.xs"
{
    RETVAL = &PL_sv_undef;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) { SvREFCNT_inc(RETVAL = args[i]); break; });
}
#line 865 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_firstres); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_firstres)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 565 "MoreUtils.xs"
{
    RETVAL = &PL_sv_undef;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) { SvREFCNT_inc(RETVAL = *PL_stack_sp); break; });
}
#line 888 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_onlyidx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_onlyidx)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 577 "MoreUtils.xs"
{
    int found = 0;
    RETVAL = -1;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) { if (found++) {RETVAL = -1; break;} RETVAL = i-1; });
}
#line 913 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_onlyval); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_onlyval)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 590 "MoreUtils.xs"
{
    int found = 0;
    RETVAL = &PL_sv_undef;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) { if (found++) {SvREFCNT_dec(RETVAL); RETVAL = &PL_sv_undef; break;} SvREFCNT_inc(RETVAL = args[i]); });
}
#line 936 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_onlyres); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_onlyres)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 603 "MoreUtils.xs"
{
    int found = 0;
    RETVAL = &PL_sv_undef;
    FOR_EACH(if (SvTRUE(*PL_stack_sp)) { if (found++) {SvREFCNT_dec(RETVAL); RETVAL = &PL_sv_undef; break;}SvREFCNT_inc(RETVAL = *PL_stack_sp); });
}
#line 960 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_lastidx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_lastidx)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 616 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    RETVAL = -1;

    if (items > 1) {
	_cv = sv_2cv(code, &stash, &gv, 0);
	PUSH_MULTICALL(_cv);
	SAVESPTR(GvSV(PL_defgv));

	for (i = items-1 ; i > 0 ; --i) {
	    GvSV(PL_defgv) = args[i];
	    MULTICALL;
	    if (SvTRUE(*PL_stack_sp)) {
		RETVAL = i-1;
		break;
	    }
	}
	POP_MULTICALL;
    }
}
#line 1010 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_lastval); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_lastval)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 654 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    RETVAL = &PL_sv_undef;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items > 1) {
	_cv = sv_2cv(code, &stash, &gv, 0);
	PUSH_MULTICALL(_cv);
	SAVESPTR(GvSV(PL_defgv));

	for (i = items-1 ; i > 0 ; --i) {
	    GvSV(PL_defgv) = args[i];
	    MULTICALL;
	    if (SvTRUE(*PL_stack_sp)) {
		/* see comment in indexes() */
		SvREFCNT_inc(RETVAL = args[i]);
		break;
	    }
	}
	POP_MULTICALL;
    }
}
#line 1059 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_lastres); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_lastres)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 693 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    RETVAL = &PL_sv_undef;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items > 1) {
	_cv = sv_2cv(code, &stash, &gv, 0);
	PUSH_MULTICALL(_cv);
	SAVESPTR(GvSV(PL_defgv));

	for (i = items-1 ; i > 0 ; --i) {
	    GvSV(PL_defgv) = args[i];
	    MULTICALL;
	    if (SvTRUE(*PL_stack_sp)) {
		/* see comment in indexes() */
		SvREFCNT_inc(RETVAL = *PL_stack_sp);
		break;
	    }
	}
	POP_MULTICALL;
    }
}
#line 1109 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_insert_after); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_insert_after)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "code, val, avref");
    {
	SV *	code = ST(0)
;
	SV *	val = ST(1)
;
	SV *	avref = ST(2)
;
	int	RETVAL;
	dXSTARG;
#line 734 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    int len;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    CV *_cv;
    AV *av;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, val, \\@area_of_operation");
    if(!arraylike(avref))
       croak_xs_usage(cv,  "code, val, \\@area_of_operation");

    av = (AV*)SvRV(avref);
    len = av_len(av);
    RETVAL = 0;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for (i = 0; i <= len ; ++i) {
	GvSV(PL_defgv) = *av_fetch(av, i, FALSE);
	MULTICALL;
	if (SvTRUE(*PL_stack_sp)) {
	    RETVAL = 1;
	    break;
	}
    }

    POP_MULTICALL;

    if (RETVAL) {
	SvREFCNT_inc(val);
	insert_after(i, val, av);
    }
}
#line 1172 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_insert_after_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_insert_after_string)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "string, val, avref");
    {
	SV *	string = ST(0)
;
	SV *	val = ST(1)
;
	SV *	avref = ST(2)
;
	int	RETVAL;
	dXSTARG;
#line 783 "MoreUtils.xs"
    {
	int i;
	AV *av;
	int len;
	SV **sv;
	STRLEN slen = 0, alen;
	char *str;
	char *astr;
	RETVAL = 0;

	if(!arraylike(avref))
	   croak_xs_usage(cv,  "string, val, \\@area_of_operation");

	av = (AV*)SvRV(avref);
	len = av_len(av);

	if (SvTRUE(string))
	    str = SvPV(string, slen);
	else
	    str = NULL;

	for (i = 0; i <= len ; i++) {
	    sv = av_fetch(av, i, FALSE);
	    if (SvTRUE(*sv))
		astr = SvPV(*sv, alen);
	    else {
		astr = NULL;
		alen = 0;
	    }
	    if (slen == alen && memcmp(astr, str, slen) == 0) {
		RETVAL = 1;
		break;
	    }
	}
	if (RETVAL) {
	    SvREFCNT_inc(val);
	    insert_after(i, val, av);
	}

    }
#line 1235 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_apply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_apply)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 831 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    CV *_cv;
    SV **args = &PL_stack_base[ax];

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items <= 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for(i = 1 ; i < items ; ++i) {
	GvSV(PL_defgv) = newSVsv(args[i]);
	MULTICALL;
	args[i-1] = GvSV(PL_defgv);
    }
    POP_MULTICALL;

    for(i = 1 ; i < items ; ++i)
        sv_2mortal(args[i-1]);

    XSRETURN(items-1);
}
#line 1283 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_after); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_after)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 868 "MoreUtils.xs"
{
    dMULTICALL;
    int i, j;
    HV *stash;
    CV *_cv;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items <= 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for (i = 1; i < items; i++) {
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	if (SvTRUE(*PL_stack_sp)) {
	    break;
	}
    }

    POP_MULTICALL;

    for (j = i + 1; j < items; ++j)
	args[j-i-1] = args[j];

    XSRETURN(items-i-1);
}
#line 1333 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_after_incl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_after_incl)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 908 "MoreUtils.xs"
{
    dMULTICALL;
    int i, j;
    HV *stash;
    CV *_cv;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items <= 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for (i = 1; i < items; i++) {
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	if (SvTRUE(*PL_stack_sp)) {
	    break;
	}
    }

    POP_MULTICALL;

    for (j = i; j < items; j++)
	args[j-i] = args[j];

    XSRETURN(items-i);
}
#line 1383 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_before); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_before)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 948 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items <= 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for (i = 1; i < items; i++) {
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	if (SvTRUE(*PL_stack_sp)) {
	    break;
	}
	args[i-1] = args[i];
    }

    POP_MULTICALL;

    XSRETURN(i-1);
}
#line 1431 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_before_incl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_before_incl)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 986 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items <= 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for (i = 1; i < items; ++i) {
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	args[i-1] = args[i];
	if (SvTRUE(*PL_stack_sp)) {
	    ++i;
	    break;
	}
    }

    POP_MULTICALL;

    XSRETURN(i-1);
}
#line 1480 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils_indexes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_indexes)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 1025 "MoreUtils.xs"
{
    dMULTICALL;
    int i, j;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items <= 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for (i = 1, j = 0; i < items; i++) {
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	if (SvTRUE(*PL_stack_sp))
            /* POP_MULTICALL can free mortal temporaries, so we defer
             * mortalising the returned values till after that's been
             * done */
	    args[j++] = newSViv(i-1);
    }

    POP_MULTICALL;

    for (i = 0; i < j; i++)
        sv_2mortal(args[i]);

    XSRETURN(j);
}
#line 1532 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_List__MoreUtils__array_iterator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils__array_iterator)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "method = \"\"");
    {
	const char *	method;

	if (items < 1)
	    method = "";
	else {
	    method = (const char *)SvPV_nolen(ST(0))
;
	}
#line 1067 "MoreUtils.xs"
    {
	int i;
	int exhausted = 1;

	/* 'cv' is the hidden argument with which XS_List__MoreUtils__array_iterator (this XSUB)
	 * is called. The closure_arg struct is stored in this CV. */

	arrayeach_args *args = (arrayeach_args *)(CvXSUBANY(cv).any_ptr);

	if (strEQ(method, "index")) {
	    EXTEND(SP, 1);
	    ST(0) = args->curidx > 0 ? sv_2mortal(newSViv(args->curidx-1)) : &PL_sv_undef;
	    XSRETURN(1);
	}

	EXTEND(SP, args->navs);

	for (i = 0; i < args->navs; i++) {
	    AV *av = args->avs[i];
	    if (args->curidx <= av_len(av)) {
		ST(i) = sv_2mortal(newSVsv(*av_fetch(av, args->curidx, FALSE)));
		exhausted = 0;
		continue;
	    }
	    ST(i) = &PL_sv_undef;
	}

	if (exhausted)
	    XSRETURN_EMPTY;

	args->curidx++;
	XSRETURN(args->navs);
    }
#line 1587 "MoreUtils.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_each_array); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_each_array)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	RETVAL;
#line 1105 "MoreUtils.xs"
    {
	EACH_ARRAY_BODY;
    }
#line 1604 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_each_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_each_arrayref)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	RETVAL;
#line 1114 "MoreUtils.xs"
    {
	EACH_ARRAY_BODY;
    }
#line 1623 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}

#if 0
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_List__MoreUtils__pairwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils__pairwise)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	code = ST(0)
;
#line 1126 "MoreUtils.xs"
    {
#define av_items(a) (av_len(a)+1)

	int i;
	AV *avs[2];
	SV **oldsp;

	int nitems = 0, maxitems = 0;

	if(!codelike(code))
	   croak_xs_usage(cv,  "code, ...");

	/* deref AV's for convenience and
	 * get maximum items */
	avs[0] = (AV*)SvRV(ST(1));
	avs[1] = (AV*)SvRV(ST(2));
	maxitems = av_items(avs[0]);
	if (av_items(avs[1]) > maxitems)
	    maxitems = av_items(avs[1]);

	if (!PL_firstgv || !PL_secondgv) {
	    SAVESPTR(PL_firstgv);
	    SAVESPTR(PL_secondgv);
	    PL_firstgv = gv_fetchpv("a", TRUE, SVt_PV);
	    PL_secondgv = gv_fetchpv("b", TRUE, SVt_PV);
	}

	oldsp = PL_stack_base;
	EXTEND(SP, maxitems);
	ENTER;
	for (i = 0; i < maxitems; i++) {
	    int nret;
	    SV **svp = av_fetch(avs[0], i, FALSE);
	    GvSV(PL_firstgv) = svp ? *svp : &PL_sv_undef;
	    svp = av_fetch(avs[1], i, FALSE);
	    GvSV(PL_secondgv) = svp ? *svp : &PL_sv_undef;
	    PUSHMARK(SP);
	    PUTBACK;
	    nret = call_sv(code, G_EVAL|G_ARRAY);
            if (SvTRUE(ERRSV))
                croak("%s", SvPV_nolen(ERRSV));
	    SPAGAIN;
	    nitems += nret;
	    while (nret--) {
		SvREFCNT_inc(*PL_stack_sp++);
	    }
	}
	PL_stack_base = oldsp;
	LEAVE;
	XSRETURN(nitems);
    }
#line 1697 "MoreUtils.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_List__MoreUtils_pairwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_pairwise)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	code = ST(0)
;
#line 1185 "MoreUtils.xs"
    {
#define av_items(a) (av_len(a)+1)

	/* This function is not quite as efficient as it ought to be: We call
	 * 'code' multiple times and want to gather its return values all in
	 * one list. However, each call resets the stack pointer so there is no
	 * obvious way to get the return values onto the stack without making
	 * intermediate copies of the pointers.  The above disabled solution
	 * would be more efficient. Unfortunately it doesn't work (and, as of
	 * now, wouldn't deal with 'code' returning more than one value).
	 *
	 * The current solution is a fair trade-off. It only allocates memory
	 * for a list of SV-pointers, as many as there are return values. It
	 * temporarily stores 'code's return values in this list and, when
	 * done, copies them down to SP. */

	int i, j;
	AV *avs[2];
	SV **buf, **p;	/* gather return values here and later copy down to SP */
	int alloc;

	int nitems = 0, maxitems = 0;
	int d;

	if(!codelike(code))
	   croak_xs_usage(cv,  "code, list, list");
	if(!arraylike(ST(1)))
	   croak_xs_usage(cv,  "code, list, list");
	if(!arraylike(ST(2)))
	   croak_xs_usage(cv,  "code, list, list");

	if (in_pad(code)) {
	    croak("Can't use lexical $a or $b in pairwise code block");
	}

	/* deref AV's for convenience and
	 * get maximum items */
	avs[0] = (AV*)SvRV(ST(1));
	avs[1] = (AV*)SvRV(ST(2));
	maxitems = av_items(avs[0]);
	if (av_items(avs[1]) > maxitems)
	    maxitems = av_items(avs[1]);

	if (!PL_firstgv || !PL_secondgv) {
	    SAVESPTR(PL_firstgv);
	    SAVESPTR(PL_secondgv);
	    PL_firstgv = gv_fetchpv("a", TRUE, SVt_PV);
	    PL_secondgv = gv_fetchpv("b", TRUE, SVt_PV);
	}

	New(0, buf, alloc = maxitems, SV*);

	ENTER;
	for (d = 0, i = 0; i < maxitems; i++) {
	    int nret;
	    SV **svp = av_fetch(avs[0], i, FALSE);
	    GvSV(PL_firstgv) = svp ? *svp : &PL_sv_undef;
	    svp = av_fetch(avs[1], i, FALSE);
	    GvSV(PL_secondgv) = svp ? *svp : &PL_sv_undef;
	    PUSHMARK(SP);
	    PUTBACK;
	    nret = call_sv(code, G_EVAL|G_ARRAY);
            if (SvTRUE(ERRSV)) {
                Safefree(buf);
                croak("%s", SvPV_nolen(ERRSV));
            }
	    SPAGAIN;
	    nitems += nret;
	    if (nitems > alloc) {
		alloc <<= 2;
		Renew(buf, alloc, SV*);
	    }
	    for (j = nret-1; j >= 0; j--) {
		/* POPs would return elements in reverse order */
		buf[d] = sp[-j];
		d++;
	    }
	    sp -= nret;
	}
	LEAVE;
	EXTEND(SP, nitems);
	p = buf;
	for (i = 0; i < nitems; i++)
	    ST(i) = *p++;

	Safefree(buf);
	XSRETURN(nitems);
    }
#line 1805 "MoreUtils.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_List__MoreUtils__natatime_iterator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils__natatime_iterator)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 1278 "MoreUtils.xs"
    {
	int i;
	int nret;

	/* 'cv' is the hidden argument with which XS_List__MoreUtils__array_iterator (this XSUB)
	 * is called. The closure_arg struct is stored in this CV. */

	natatime_args *args = (natatime_args*)CvXSUBANY(cv).any_ptr;

	nret = args->natatime;

	EXTEND(SP, nret);

	for (i = 0; i < args->natatime; i++) {
	    if (args->curidx < args->nsvs) {
		ST(i) = sv_2mortal(newSVsv(args->svs[args->curidx++]));
	    }
	    else {
		XSRETURN(i);
	    }
	}

	XSRETURN(nret);
    }
#line 1844 "MoreUtils.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_natatime); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_natatime)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "n, ...");
    {
	int	n = (int)SvIV(ST(0))
;
	SV *	RETVAL;
#line 1308 "MoreUtils.xs"
    {
	int i;
	natatime_args * args;
	HV *stash = gv_stashpv("List::MoreUtils_na", TRUE);

	CV *closure = newXS(NULL, XS_List__MoreUtils__natatime_iterator, __FILE__);

	/* must NOT set prototype on iterator:
	 * otherwise one cannot write: &$it */
	/* !! sv_setpv((SV*)closure, ""); !! */

	New(0, args, 1, natatime_args);
	New(0, args->svs, items-1, SV*);
	args->nsvs = items-1;
	args->curidx = 0;
	args->natatime = n;

	for (i = 1; i < items; i++)
	    SvREFCNT_inc(args->svs[i-1] = ST(i));

	CvXSUBANY(closure).any_ptr = args;
	RETVAL = newRV_noinc((SV*)closure);

	/* in order to allow proper cleanup in DESTROY-handler */
	sv_bless(RETVAL, stash);
    }
#line 1887 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_mesh)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1341 "MoreUtils.xs"
    {
	int i, j, maxidx = -1;
	AV **avs;
	New(0, avs, items, AV*);

	for (i = 0; i < items; i++) {
	    if(!arraylike(ST(i)))
	       croak_xs_usage(cv,  "\\@;\\@\\@...");
	    avs[i] = (AV*)SvRV(ST(i));
	    if (av_len(avs[i]) > maxidx)
		maxidx = av_len(avs[i]);
	}

	EXTEND(SP, items * (maxidx + 1));
	for (i = 0; i <= maxidx; i++)
	    for (j = 0; j < items; j++) {
		SV **svp = av_fetch(avs[j], i, FALSE);
		ST(i*items + j) = svp ? sv_2mortal(newSVsv(*svp)) : &PL_sv_undef;
	    }

	Safefree(avs);
	XSRETURN(items * (maxidx + 1));
    }
#line 1925 "MoreUtils.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_uniq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_uniq)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1369 "MoreUtils.xs"
    {
	I32 i;
	IV count = 0, seen_undef = 0;
	HV *hv = newHV();
        SV **args = &PL_stack_base[ax];
	SV *tmp = sv_newmortal();
	sv_2mortal(newRV_noinc((SV*)hv));

	/* don't build return list in scalar context */
	if (GIMME_V == G_SCALAR) {
	    for (i = 0; i < items; i++) {
		SvGETMAGIC(args[i]);
		if(SvOK(args[i])) {
		    sv_setsv_nomg(tmp, args[i]);
		    if (!hv_exists_ent(hv, tmp, 0)) {
			++count;
			hv_store_ent(hv, tmp, &PL_sv_yes, 0);
		    }
		}
		else if(0 == seen_undef++) {
		    ++count;
		}
	    }
	    ST(0) = sv_2mortal(newSVuv(count));
	    XSRETURN(1);
	}

	/* list context: populate SP with mortal copies */
	for (i = 0; i < items; i++) {
	    SvGETMAGIC(args[i]);
	    if(SvOK(args[i])) {
		SvSetSV_nosteal(tmp, args[i]);
		if (!hv_exists_ent(hv, tmp, 0)) {
		    /*ST(count) = sv_2mortal(newSVsv(ST(i)));
		    ++count;*/
		    args[count++] = args[i];
		    hv_store_ent(hv, tmp, &PL_sv_yes, 0);
		}
	    }
	    else if(0 == seen_undef++) {
		args[count++] = args[i];
	    }
	}

	XSRETURN(count);
    }
#line 1984 "MoreUtils.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_singleton); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_singleton)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1420 "MoreUtils.xs"
    {
	I32 i;
	IV cnt = 0, count = 0, seen_undef = 0;
	HV *hv = newHV();
        SV **args = &PL_stack_base[ax];
	SV *tmp = sv_newmortal();

	sv_2mortal(newRV_noinc((SV*)hv));

	for (i = 0; i < items; i++) {
	    SvGETMAGIC(args[i]);
	    if(SvOK(args[i])) {
		HE *he;
		SvSetSV_nosteal(tmp, args[i]);
		he = hv_fetch_ent(hv, tmp, 0, 0);
		if (NULL == he) {
		    /* ST(count) = sv_2mortal(newSVsv(ST(i))); */
		    args[count++] = args[i];
		    hv_store_ent(hv, tmp, newSViv(1), 0);
		}
		else {
		    SV *v = HeVAL(he);
		    IV how_many = SvIVX(v);
		    sv_setiv(v, ++how_many);
		}
	    }
	    else if(0 == seen_undef++) {
		args[count++] = args[i];
	    }
	}

	/* don't build return list in scalar context */
	if (GIMME_V == G_SCALAR) {
	    for (i = 0; i < count; i++) {
		if(SvOK(args[i])) {
		    HE *he;
			sv_setsv_nomg(tmp, args[i]);
		    he = hv_fetch_ent(hv, tmp, 0, 0);
		    if (he) {
			SV *v = HeVAL(he);
			IV how_many = SvIVX(v);
			if( 1 == how_many )
			    ++cnt;
		    }
		}
		else if(1 == seen_undef) {
		    ++cnt;
		}
	    }
	    ST(0) = sv_2mortal(newSViv(cnt));
	    XSRETURN(1);
	}

	/* list context: populate SP with mortal copies */
	for (i = 0; i < count; i++) {
	    if(SvOK(args[i])) {
		HE *he;
		SvSetSV_nosteal(tmp, args[i]);
		he = hv_fetch_ent(hv, tmp, 0, 0);
		if (he) {
		    SV *v = HeVAL(he);
		    IV how_many = SvIVX(v);
		    if( 1 == how_many )
			args[cnt++] = args[i];
		}
	    }
	    else if(1 == seen_undef) {
		args[cnt++] = args[i];
	    }
	}

	XSRETURN(cnt);
    }
#line 2070 "MoreUtils.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_minmax); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_minmax)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
#line 1498 "MoreUtils.xs"
    {
	I32 i;
	SV *minsv, *maxsv;

	if (!items)
	    XSRETURN_EMPTY;

	minsv = maxsv = ST(0);

        if (items == 1) {
            EXTEND(SP, 1);
            ST(0) = ST(1) = minsv;
            XSRETURN(2);
        }

	for (i = 1; i < items; i += 2) {
	    SV *asv = ST(i-1);
	    SV *bsv = ST(i);
	    int cmp = ncmp(asv, bsv);
	    if (cmp < 0) {
		int min_cmp = ncmp(minsv, asv);
		int max_cmp = ncmp(maxsv, bsv);
		if (min_cmp > 0) {
		    minsv = asv;
		}
		if (max_cmp < 0) {
		    maxsv = bsv;
		}
	    } else {
		int min_cmp = ncmp(minsv, bsv);
		int max_cmp = ncmp(maxsv, asv);
		if (min_cmp > 0) {
		    minsv = bsv;
		}
		if (max_cmp < 0) {
		    maxsv = asv;
		}
	    }
	}

	if (items & 1) {
	    SV *rsv = ST(items-1);
	    if (ncmp(minsv, rsv) > 0) {
		minsv = rsv;
	    }
	    else if (ncmp(maxsv, rsv) < 0) {
		maxsv = rsv;
	    }
	}
	ST(0) = minsv;
	ST(1) = maxsv;

	XSRETURN(2);
    }
#line 2137 "MoreUtils.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_part); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_part)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 1558 "MoreUtils.xs"
{
    dMULTICALL;
    int i;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    SV **args = &PL_stack_base[ax];
    CV *_cv;

    AV **tmp = NULL;
    int last = 0;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items == 1)
	XSRETURN_EMPTY;

    _cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(_cv);
    SAVESPTR(GvSV(PL_defgv));

    for(i = 1 ; i < items ; ++i) {
	int idx;
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	idx = SvIV(*PL_stack_sp);

	if (idx < 0 && (idx += last) < 0)
	    croak("Modification of non-creatable array value attempted, subscript %i", idx);

	if (idx >= last) {
	    int oldlast = last;
	    last = idx + 1;
	    Renew(tmp, last, AV*);
	    Zero(tmp + oldlast, last - oldlast, AV*);
	}
	if (!tmp[idx])
	    tmp[idx] = newAV();
	av_push(tmp[idx], args[i]);
	SvREFCNT_inc(args[i]);
    }
    POP_MULTICALL;

    EXTEND(SP, last);
    for (i = 0; i < last; ++i) {
        if (tmp[i])
            ST(i) = sv_2mortal(newRV_noinc((SV*)tmp[i]));
        else
            ST(i) = &PL_sv_undef;
    }

    Safefree(tmp);
    XSRETURN(last);
}
#line 2208 "MoreUtils.c"
    }
    XSRETURN(1);
}

#if 0
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_List__MoreUtils_part_dhash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_part_dhash)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
#line 1620 "MoreUtils.xs"
{
    /* We might want to keep this dhash-implementation.
     * It is currently slower than the above but it uses less
     * memory for sparse parts such as
     *   @part = part { 10_000_000 } 1 .. 100_000;
     * Maybe there's a way to optimize dhash.h to get more speed
     * from it.
     */
    dMULTICALL;
    int i, j, lastidx = -1;
    int max;
    HV *stash;
    GV *gv;
    I32 gimme = G_SCALAR;
    I32 count = 0;
    SV **args = &PL_stack_base[ax];
    CV *cv;

    dhash_t *h = dhash_init();

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items == 1)
	XSRETURN_EMPTY;

    cv = sv_2cv(code, &stash, &gv, 0);
    PUSH_MULTICALL(cv);
    SAVESPTR(GvSV(PL_defgv));

    for(i = 1 ; i < items ; ++i) {
	int idx;
	GvSV(PL_defgv) = args[i];
	MULTICALL;
	idx = SvIV(*PL_stack_sp);

	if (idx < 0 && (idx += h->max) < 0)
	    croak("Modification of non-creatable array value attempted, subscript %i", idx);

	dhash_store(h, idx, args[i]);
    }
    POP_MULTICALL;

    dhash_sort_final(h);

    EXTEND(SP, max = h->max+1);
    i = 0;
    lastidx = -1;
    while (i < h->count) {
	int retidx = h->ary[i].key;
	int fill = retidx - lastidx - 1;
	for (j = 0; j < fill; j++) {
	    ST(retidx - j - 1) = &PL_sv_undef;
	}
	ST(retidx) = newRV_noinc((SV*)h->ary[i].val);
	i++;
	lastidx = retidx;
    }

    dhash_destroy(h);
    XSRETURN(max);
}
#line 2289 "MoreUtils.c"
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_List__MoreUtils_bsearch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_bsearch)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	SV *	RETVAL;
#line 1690 "MoreUtils.xs"
{
    dMULTICALL;
    HV *stash;
    GV *gv;
    I32 gimme = GIMME_V; /* perl-5.5.4 bus-errors out later when using GIMME
                            therefore we save its value in a fresh variable */
    SV **args = &PL_stack_base[ax];

    long i, j;
    int val = -1;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    if (items > 1) {
	CV *_cv = sv_2cv(code, &stash, &gv, 0);
	PUSH_MULTICALL(_cv);
	SAVESPTR(GvSV(PL_defgv));

        i = 0;
        j = items - 1;
        do {
            long k = (i + j) / 2;

            if (k >= items-1)
                break;

            GvSV(PL_defgv) = args[1+k];
            MULTICALL;
            val = SvIV(*PL_stack_sp);

            if (val == 0) {
                POP_MULTICALL;
                if (gimme != G_ARRAY) {
                    XSRETURN_YES;
		}
                SvREFCNT_inc(RETVAL = args[1+k]);
                goto yes;
            }
            if (val < 0) {
                i = k+1;
            } else {
                j = k-1;
            }
        } while (i <= j);
        POP_MULTICALL;
    }

    if (gimme == G_ARRAY)
        XSRETURN_EMPTY;
    else
        XSRETURN_UNDEF;
yes:
    ;
}
#line 2362 "MoreUtils.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils_bsearchidx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils_bsearchidx)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "code, ...");
    {
	SV *	code = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 1753 "MoreUtils.xs"
{
    dMULTICALL;
    HV *stash;
    GV *gv;
    I32 gimme = GIMME_V; /* perl-5.5.4 bus-errors out later when using GIMME
                            therefore we save its value in a fresh variable */
    SV **args = &PL_stack_base[ax];

    long i, j;
    int val = -1;

    if(!codelike(code))
       croak_xs_usage(cv,  "code, ...");

    RETVAL = -1;

    if (items > 1) {
	CV *_cv = sv_2cv(code, &stash, &gv, 0);
	PUSH_MULTICALL(_cv);
	SAVESPTR(GvSV(PL_defgv));

        i = 0;
        j = items - 1;
        do {
            long k = (i + j) / 2;

            if (k >= items-1)
                break;

            GvSV(PL_defgv) = args[1+k];
            MULTICALL;
            val = SvIV(*PL_stack_sp);

            if (val == 0) {
                RETVAL = k;
                break;
            }
            if (val < 0) {
                i = k+1;
            } else {
                j = k-1;
            }
        } while (i <= j);
        POP_MULTICALL;
    }
}
#line 2428 "MoreUtils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_List__MoreUtils__XScompiled); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_List__MoreUtils__XScompiled)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 1805 "MoreUtils.xs"
       XSRETURN_YES;
#line 2444 "MoreUtils.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_List__MoreUtils); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_List__MoreUtils)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("List::MoreUtils_ea::DESTROY", XS_List__MoreUtils_ea_DESTROY);
        newXS_deffile("List::MoreUtils_na::DESTROY", XS_List__MoreUtils_na_DESTROY);
        (void)newXSproto_portable("List::MoreUtils::any", XS_List__MoreUtils_any, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::all", XS_List__MoreUtils_all, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::none", XS_List__MoreUtils_none, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::notall", XS_List__MoreUtils_notall, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::one", XS_List__MoreUtils_one, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::any_u", XS_List__MoreUtils_any_u, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::all_u", XS_List__MoreUtils_all_u, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::none_u", XS_List__MoreUtils_none_u, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::notall_u", XS_List__MoreUtils_notall_u, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::one_u", XS_List__MoreUtils_one_u, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::true", XS_List__MoreUtils_true, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::false", XS_List__MoreUtils_false, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::firstidx", XS_List__MoreUtils_firstidx, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::firstval", XS_List__MoreUtils_firstval, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::firstres", XS_List__MoreUtils_firstres, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::onlyidx", XS_List__MoreUtils_onlyidx, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::onlyval", XS_List__MoreUtils_onlyval, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::onlyres", XS_List__MoreUtils_onlyres, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::lastidx", XS_List__MoreUtils_lastidx, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::lastval", XS_List__MoreUtils_lastval, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::lastres", XS_List__MoreUtils_lastres, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::insert_after", XS_List__MoreUtils_insert_after, file, "&$\\@");
        (void)newXSproto_portable("List::MoreUtils::insert_after_string", XS_List__MoreUtils_insert_after_string, file, "$$\\@");
        (void)newXSproto_portable("List::MoreUtils::apply", XS_List__MoreUtils_apply, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::after", XS_List__MoreUtils_after, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::after_incl", XS_List__MoreUtils_after_incl, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::before", XS_List__MoreUtils_before, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::before_incl", XS_List__MoreUtils_before_incl, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::indexes", XS_List__MoreUtils_indexes, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::_array_iterator", XS_List__MoreUtils__array_iterator, file, ";$");
        (void)newXSproto_portable("List::MoreUtils::each_array", XS_List__MoreUtils_each_array, file, "\\@;\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@");
        newXS_deffile("List::MoreUtils::each_arrayref", XS_List__MoreUtils_each_arrayref);
#if XSubPPtmpAAAA
        (void)newXSproto_portable("List::MoreUtils::_pairwise", XS_List__MoreUtils__pairwise, file, "&\\@\\@");
#endif
        (void)newXSproto_portable("List::MoreUtils::pairwise", XS_List__MoreUtils_pairwise, file, "&\\@\\@");
        (void)newXSproto_portable("List::MoreUtils::_natatime_iterator", XS_List__MoreUtils__natatime_iterator, file, "");
        (void)newXSproto_portable("List::MoreUtils::natatime", XS_List__MoreUtils_natatime, file, "$@");
        (void)newXSproto_portable("List::MoreUtils::mesh", XS_List__MoreUtils_mesh, file, "\\@\\@;\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@\\@");
        (void)newXSproto_portable("List::MoreUtils::uniq", XS_List__MoreUtils_uniq, file, "@");
        (void)newXSproto_portable("List::MoreUtils::singleton", XS_List__MoreUtils_singleton, file, "@");
        (void)newXSproto_portable("List::MoreUtils::minmax", XS_List__MoreUtils_minmax, file, "@");
        (void)newXSproto_portable("List::MoreUtils::part", XS_List__MoreUtils_part, file, "&@");
#if XSubPPtmpAAAB
        (void)newXSproto_portable("List::MoreUtils::part_dhash", XS_List__MoreUtils_part_dhash, file, "&@");
#endif
        (void)newXSproto_portable("List::MoreUtils::bsearch", XS_List__MoreUtils_bsearch, file, "&@");
        (void)newXSproto_portable("List::MoreUtils::bsearchidx", XS_List__MoreUtils_bsearchidx, file, "&@");
        newXS_deffile("List::MoreUtils::_XScompiled", XS_List__MoreUtils__XScompiled);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#line 2535 "MoreUtils.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}


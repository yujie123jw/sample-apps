/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Util.xs. Do not edit this file, edit Util.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Util.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Changes in 5.7 series mean that now IOK is only set if scalar is
   precisely integer but in 5.6 and earlier we need to do a more
   complex test  */
#if PERL_VERSION <= 6
#define DD_is_integer(sv) (SvIOK(sv) && (SvIsUV(val) ? SvUV(sv) == SvNV(sv) : SvIV(sv) == SvNV(sv)))
#else
#define DD_is_integer(sv) SvIOK(sv)
#endif

static int
is_string0( SV *sv )
{
    return SvFLAGS(sv) & (SVf_OK & ~SVf_ROK);
}

static int
is_string( SV *sv )
{
    STRLEN len = 0;
    if( is_string0(sv) )
    {
        const char *pv = SvPV(sv, len);
    }
    return len;
}

static int
is_array( SV *sv )
{
    return SvROK(sv) && ( SVt_PVAV == SvTYPE(SvRV(sv) ) );
}

static int
is_hash( SV *sv )
{
    return SvROK(sv) && ( SVt_PVHV == SvTYPE(SvRV(sv) ) );
}

static int
is_like( SV *sv, const char *like )
{
    int likely = 0;
    if( sv_isobject( sv ) )
    {
        dSP;
        int count;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP);
        XPUSHs( sv_2mortal( newSVsv( sv ) ) );
        XPUSHs( sv_2mortal( newSVpv( like, strlen(like) ) ) );
        PUTBACK;

        if( ( count = call_pv("overload::Method", G_SCALAR) ) )
        {
            I32 ax;
            SPAGAIN;

            SP -= count;
            ax = (SP - PL_stack_base) + 1;
            if( SvTRUE(ST(0)) )
                ++likely;
        }

        PUTBACK;
        FREETMPS;
        LEAVE;
    }

    return likely;
}

#line 88 "Util.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 230 "Util.c"

XS_EUPXS(XS_Params__Util__STRING); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__STRING)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 85 "Util.xs"
{
    if( SvMAGICAL(sv) )
        mg_get(sv);
    if( is_string( sv ) )
    {
        ST(0) = sv;
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#line 252 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__NUMBER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__NUMBER)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 101 "Util.xs"
{
    if( SvMAGICAL(sv) )
        mg_get(sv);
    if( ( SvIOK(sv) ) || ( SvNOK(sv) ) || ( is_string( sv ) && looks_like_number( sv ) ) )
    {
        ST(0) = sv;
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#line 278 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__SCALAR0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__SCALAR0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 117 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( ( SvTYPE(SvRV(ref)) <= SVt_PVBM ) && !sv_isobject(ref) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 307 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__SCALAR); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__SCALAR)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 136 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        svtype tp = SvTYPE(SvRV(ref));
        if( ( SvTYPE(SvRV(ref)) <= SVt_PVBM ) && (!sv_isobject(ref)) && is_string( SvRV(ref) ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 337 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__REGEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__REGEX)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 156 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        svtype tp = SvTYPE(SvRV(ref));
#if PERL_VERSION >= 11
        if( ( SVt_REGEXP == tp ) )
#else
        if( ( SVt_PVMG == tp ) && sv_isobject(ref)
         && ( 0 == strncmp( "Regexp", sv_reftype(SvRV(ref),TRUE),
                            strlen("Regexp") ) ) )
#endif
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 373 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__ARRAY0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__ARRAY0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 182 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_array(ref) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }

    XSRETURN_UNDEF;
}
#line 400 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 199 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_array(ref) && ( av_len((AV *)(SvRV(ref))) >= 0 ) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#line 426 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__ARRAYLIKE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__ARRAYLIKE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 215 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( is_array(ref) || is_like( ref, "@{}" ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }

    XSRETURN_UNDEF;
}
#line 456 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__HASH0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__HASH0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 235 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_hash(ref) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }

    XSRETURN_UNDEF;
}
#line 483 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 252 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( is_hash(ref) && ( HvKEYS(SvRV(ref)) >= 1 ) )
    {
        ST(0) = ref;
        XSRETURN(1);
    }

    XSRETURN_UNDEF;
}
#line 510 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__HASHLIKE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__HASHLIKE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 269 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( is_hash(ref) || is_like( ref, "%{}" ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }

    XSRETURN_UNDEF;
}
#line 540 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__CODE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__CODE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 289 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( SVt_PVCV == SvTYPE(SvRV(ref)) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 569 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__CODELIKE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__CODELIKE)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ref");
    {
	SV *	ref = ST(0)
;
#line 308 "Util.xs"
{
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) )
    {
        if( ( SVt_PVCV == SvTYPE(SvRV(ref)) ) || ( is_like(ref, "&{}" ) ) )
        {
            ST(0) = ref;
            XSRETURN(1);
        }
    }
    XSRETURN_UNDEF;
}
#line 598 "Util.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Params__Util__INSTANCE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Params__Util__INSTANCE)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ref, type");
    {
	SV *	ref = ST(0)
;
	char *	type = (char *)SvPV_nolen(ST(1))
;
#line 328 "Util.xs"
{
    STRLEN len;
    if( SvMAGICAL(ref) )
        mg_get(ref);
    if( SvROK(ref) && type && ( ( len = strlen(type) ) > 0 ) )
    {
        if( sv_isobject(ref) )
        {
            I32 isa_type = 0;
            int count;

            ENTER;
            SAVETMPS;
            PUSHMARK(SP);
            XPUSHs( sv_2mortal( newSVsv( ref ) ) );
            XPUSHs( sv_2mortal( newSVpv( type, len ) ) );
            PUTBACK;

            if( ( count = call_method("isa", G_SCALAR) ) )
            {
                I32 oldax = ax;
                SPAGAIN;
                SP -= count;
                ax = (SP - PL_stack_base) + 1;
                isa_type = SvTRUE(ST(0));
                ax = oldax;
            }

            PUTBACK;
            FREETMPS;
            LEAVE;

            if( isa_type )
            {
                ST(0) = ref;
                XSRETURN(1);
            }
        }
    }
    XSRETURN_UNDEF;
}
#line 657 "Util.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Params__Util); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Params__Util)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Params::Util::_STRING", XS_Params__Util__STRING, file, "$");
        (void)newXSproto_portable("Params::Util::_NUMBER", XS_Params__Util__NUMBER, file, "$");
        (void)newXSproto_portable("Params::Util::_SCALAR0", XS_Params__Util__SCALAR0, file, "$");
        (void)newXSproto_portable("Params::Util::_SCALAR", XS_Params__Util__SCALAR, file, "$");
        (void)newXSproto_portable("Params::Util::_REGEX", XS_Params__Util__REGEX, file, "$");
        (void)newXSproto_portable("Params::Util::_ARRAY0", XS_Params__Util__ARRAY0, file, "$");
        (void)newXSproto_portable("Params::Util::_ARRAY", XS_Params__Util__ARRAY, file, "$");
        (void)newXSproto_portable("Params::Util::_ARRAYLIKE", XS_Params__Util__ARRAYLIKE, file, "$");
        (void)newXSproto_portable("Params::Util::_HASH0", XS_Params__Util__HASH0, file, "$");
        (void)newXSproto_portable("Params::Util::_HASH", XS_Params__Util__HASH, file, "$");
        (void)newXSproto_portable("Params::Util::_HASHLIKE", XS_Params__Util__HASHLIKE, file, "$");
        (void)newXSproto_portable("Params::Util::_CODE", XS_Params__Util__CODE, file, "$");
        (void)newXSproto_portable("Params::Util::_CODELIKE", XS_Params__Util__CODELIKE, file, "$");
        (void)newXSproto_portable("Params::Util::_INSTANCE", XS_Params__Util__INSTANCE, file, "$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

